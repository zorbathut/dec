<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Custom deserialization </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Custom deserialization ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="custom-deserialization">Custom deserialization</h1>

<p>Providing custom deserializers for your own classes, or third-party classes, requires defining classes that derive from <a href="xref:Dec.Converter"><code>Dec.Converter</code></a>. <a class="xref" href="../api/Dec.Parser.html"><code>Dec.Parser</code></a> will automatically find them during startup and register them. (Note: At this time, it is <em>required</em> to run Parser first. If you want to use Converters in a pre-parser Recorder, come pester me on Discord and I'll get it working for you.)</p>
<p>There are three converter types available. In increasing order of complexity, <a class="xref" href="../api/Dec.ConverterString-1.html"><code>Dec.ConverterString</code></a> is most useful for simple objects that fit inside a string, <a class="xref" href="../api/Dec.ConverterRecord-1.html"><code>Dec.ConverterRecord</code></a> is suitable for larger hierarchies that have a default constructor, <a class="xref" href="../api/Dec.ConverterFactory-1.html"><code>Dec.ConverterFactory</code></a> is best for anything that needs to insert complicated objects created outside the Dec system. It is recommended that you consider them in that order.</p>
<h2 id="converterstring">ConverterString</h2>
<p><a class="xref" href="../api/Dec.ConverterString-1.html"><code>Dec.ConverterString</code></a> is designed for converting to and from simple string objects. It's not suitable for objects that reference other objects, nor does it allow you to do per-field default overrides. If your data plausibly fits in a single short human-readable string, ConverterString is a great choice.</p>
<p>It is most often used for simple small data classes; vectors, colors, quaternions, die rolls such as &quot;3d6&quot;. Unlike ConverterRecord, it also allows you to return your own objects, created using constructors or provided by other libraries. This means you can use it for references to assets or handles to other objects; &quot;/monster/goblin/goblinTexture.png&quot; could plausibly resolve to an externally-created Texture object.</p>
<pre><code class="lang-cs">public class ColorConverter : Dec.ConverterString&lt;Color&gt;
{
    public override Color Read(string input, Dec.InputContext inputContext)
    {
        // Implementation of ParseColorFromString left as an exercise for the reader
        return Util.ParseColorFromString(input);
    }

    public override string Write(Color val)
    {
        return val.ToString();
    }
}

public class ExampleDec : Dec.Dec
{
    Color tintA;
    Color tintB;
}
</code></pre>
<pre><code class="lang-xml">&lt;ExampleDec decName=&quot;Example&quot;&gt;
  &lt;tintA&gt;(0.3, 0.5, 0.8)&lt;/tintA&gt;
  &lt;tintB&gt;#4C7FCC&lt;/tintB&gt;
&lt;/ExampleDec&gt;
</code></pre>
<h2 id="converterrecord">ConverterRecord</h2>
<p><a class="xref" href="../api/Dec.ConverterRecord-1.html"><code>Dec.ConverterRecord</code></a> is designed for larger and more complicated objects, possibly including entity hierarchies. It is able to reference other objects in non-tree arrangements, even with circular dependencies. Its major limitation is that ConverterRecord-created objects <em>must</em> be creatable directly from the Dec library with a default constructor.</p>
<p>It essentially provides the <a class="xref" href="../api/Dec.IRecordable.html"><code>Dec.IRecordable</code></a> interface to things that you cannot attach that interface to (but given the choice, we recommend using IRecordable instead). This means that both serialization and deserialization are packed into a single general-purpose function.</p>
<p>This is suitable for larger structured items such as matrices, quaternions, or meshes. If you didn't make the class yourself, and it doesn't fit into a string, this should be your first stop.</p>
<p>In most cases this is probably going to be used as part of savegames, not embedded in Decs.</p>
<pre><code class="lang-cs">public class MeshConverter : Dec.ConverterString&lt;Mesh&gt;
{
    public override void Record(Mesh input, Dec.Recorder recorder)
    {
        // Pretend &quot;vertices&quot; here is a List&lt;Point2&gt;
        // Point2 itself is serialized by a ConverterString.
        recorder.Record(ref input.vertices, &quot;vertices&quot;);

        // Pretend &quot;triangles&quot; is a List&lt;TriangleIdx&gt;
        // TriangleIdx is also serialized by a ConverterString.
        recorder.Record(ref input.triangles, &quot;triangles&quot;);
    }
}

public class ExampleDec : Dec.Dec
{
    Mesh mesh;
}
</code></pre>
<pre><code class="lang-xml">&lt;ExampleDec decName=&quot;Square&quot;&gt;
  &lt;mesh&gt;
    &lt;vertices&gt;
      &lt;li&gt;0, 0&lt;/li&gt;
      &lt;li&gt;0, 1&lt;/li&gt;
      &lt;li&gt;1, 0&lt;/li&gt;
      &lt;li&gt;1, 1&lt;/li&gt;
    &lt;/vertices&gt;
    &lt;indices&gt;
      &lt;li&gt;0, 1, 2&lt;/li&gt;
      &lt;li&gt;1, 3, 2&lt;/li&gt;
    &lt;/indices&gt;
  &lt;/mesh&gt;
&lt;/ExampleDec&gt;
</code></pre>
<h2 id="converterfactory">ConverterFactory</h2>
<p><a class="xref" href="../api/Dec.ConverterFactory-1.html"><code>Dec.ConverterFactory</code></a> is the most powerful and expressive converter, coupled inevitably with the most complicated interface. In most cases, you should probably not use this! It's available for the special situations where you really need it.</p>
<p>ConverterFactory is able to reference other objects in non-tree arrangements, even with circular dependencies. It can override default-provided parameters piecemeal. It can also provide preconstructed or custom-constructed objects as needed. Its biggest downside is complexity; it splits functionality into three separate functions, <a class="xref" href="../api/Dec.ConverterFactory-1.html#Dec_ConverterFactory_1_Create_">Create()</a>, <a class="xref" href="../api/Dec.ConverterFactory-1.html#Dec_ConverterFactory_1_Read_">Read()</a>, and <a class="xref" href="../api/Dec.ConverterFactory-1.html#Dec_ConverterFactory_1_Write_">Write()</a>.</p>
<p>Create() <em>may</em> be called first if an instance needs to be generated. If it has already been provided with an instance, Create() will be skipped entirely. Create() has a Recorder interface, but attempting to make a Shared reference is an error; don't do that. We recommend putting only the minimum required to construct an object in here.</p>
<p>Read() is called next, and it also has Recorder interface, this time fully-functional. Put all the rest of your data parsing in here.</p>
<p>Write() is used for serialization. This will probably look very similar to Read(), except plus whatever data will need to be stashed away for Create() to work during loading.</p>
<p>This example is for a hypothetical entity system that requires Entity objects to be constructed in specific buckets.</p>
<pre><code class="lang-cs">public class EntityConverter : Dec.ConverterFactory&lt;Entity&gt;
{
    public override Entity Create(Recorder recorder)
    {
        EntityBucket bucket = EntityBucket.Default;
        recorder.Record(ref bucket, &quot;bucket&quot;);

        return EntityManager.CreateInBucket(bucket);
    }

    public override void Read(ref Entity input, Recorder recorder)
    {
        recorder.Record(ref input.health, &quot;health&quot;);
    }

    public override void Write(Entity input, Recorder recorder)
    {
        recorder.Record(ref input.bucket, &quot;bucket&quot;);
        recorder.Record(ref input.health, &quot;health&quot;);
    }
}
</code></pre>
<pre><code class="lang-xml">&lt;!-- Assume this exists inside a Recorder xml file --&gt;
&lt;entity&gt;
  &lt;bucket&gt;Priority&lt;/bucket&gt;
  &lt;health&gt;12&lt;/health&gt;
&lt;/entity&gt;
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/zorbathut/dec/blob/feature_reader/doc/documentation/custom.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
